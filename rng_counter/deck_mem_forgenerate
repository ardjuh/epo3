library IEEE;
use IEEE.std_logic_1164.ALL;
use IEEE.numeric_std.all;

architecture behaviour of deck_mem is
	
	component enable_ff
		port(clk, reset,enable,shuffle   : in  std_logic;		
       			D      : in  std_logic_vector(4 downto 0);
      			Q      : out std_logic_vector(4 downto 0));
	end component enable_ff;

	signal summation : unsigned (7 downto 0) := to_unsigned(0,8);
	signal card : unsigned (3 downto 0);
	type memory is array (0 to 12) of unsigned(4 downto 0);
	signal mem, Q : memory;
	signal enable : std_logic;
begin	

	process(random_num)
	begin
		if random_num > "00000000" then
				
			for i in 0 to 12 loop
				mem(i) <= Q(i);
				summation <= summation + mem(i);
				if summation >= unsigned(random_num) then
					 --word kaart op plek i
					random_card <= std_logic_vector(to_unsigned(i + 1,4));
					mem(i) <= mem(i) - to_unsigned(1,5);
					enable <= '1';
					exit;
				end if;
			end loop;
		else
			random_card <= "0000";
			enable <= '0';
		end if;			
		
	end process;	

				
registers_13:	for j in 0 to 12 generate
	flip_flop : enable_ff port map (clk => clk, 
reset => reset,
 enable => enable,
shuffle => shuffle,
 D => std_logic_vector(mem(j)),
 Q => std_logic_vector(mem(j)));
				
end generate registers_13;		     
	

end behaviour;
